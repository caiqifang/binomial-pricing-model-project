{
  "name": "Parallel Computation of Binomial Security Pricing Model",
  "tagline": "CMU 15-418 Term Project",
  "body": "### Welcome\r\nOur goal of this project is to use parallel computing techniques to increase the calculating performance of binomial security pricing model. We will implement the project on Nvidia GPU platforms using CUDA API. In the end, we wish we can build a real-time program that reacts to changes in variables and returns the theoretical prices of securities. Hope this pricing engine can serve as the core of a black-box trading system.\r\n\r\n### Background Information\r\nBinomial security pricing model is a fundamental technique used in the financial industry. The idea of this model is that we can use a binomial tree to describe the evolution of security price. At time 0, we can denote the security price to be S0. At the next time period, the price S0 can evolve into S1(Head) with an up factor of u and S1(Tail) with a down factor of d. A multiple period binomial model is shown in the graph.    \r\n\r\n![](https://s13.postimg.org/zbbtnvgtv/Screen_Shot_2016_10_31_at_17_56_42.png)  \r\n\r\nPicture from Stochastic Calculus for Finance I: The Binomial Asset Pricing Model by Steven E. Shreve. (In this case, the up factor and down factor (u and d) are fixed throughout time.)\r\nTo calculate the initial price of the security, we introduce the technique of backward induction. Given the arbitrage free interest rate r, the up factor u and down factor d, the no-arbitrage price of the security at time n can be computed recursively backward in time by this equation          \r\n\r\n![](https://s13.postimg.org/k1bygolbn/Screen_Shot_2016_10_31_at_18_18_15.png) \r\n\r\nWhere p and q are the risk-neutral probabilities given by            \r\n     \r\n![](https://s13.postimg.org/njnyd2m7n/Screen_Shot_2016_10_31_at_18_23_54.png)\r\n\r\nWe can draw some quick observations of this model. The price of each tree node depends on the price of its left and right children nodes and different parameters in the backward induction formula. Different path calculates its price using different children nodes, thus paths are independent of each other. This property allows us to parallelize the calculation of an N period binomial model, theoretically improving its performance from O(2^N) to O(N) time complexity. We will need to use some data to train and calibrate the binomial model and find the best parameters (u, d, r) before we can backward induct the current correct price of the security. If a trading system sees a difference between the market price and theoretical model price, it can further exam the situation and explore potential arbitrage in the mispriced security.\r\n\r\n###THE CHALLENGE:\r\n**Problem Size** -\r\nThe nature of the binomial model presents some difficulties. As the time period increases, the total nodes in the binomial tree grows exponentially. (Total of 2^N nodes) Initially, we are aiming to have a 30-period binomial model, but we need to do some math and computer science optimizations. There is simply no platform that can calculate and store the 2^30-level binomial tree.\r\n\r\n**Memory Management** -\r\nAssume that each node only contains a single floating number, because we have 2^30 nodes in total, there will be no reasonable storage device that can store this much data. We need to find a way to compress, hash and even abandon duplicated information. At the same time, we will be accessing value in the memory frequently. There's no way we can fit everything in the cache, so we need to find a way to access data that best utilizing the GPU memory and cache.\r\n\r\n**Smart Work Distribution** -\r\nAll the security price calculation involves the backward induction equation. The calculation time does not vary too much. However, we still need to manage to distribute the calculate in a clever way to best utilize the GPU.\r\n\r\n**Model Training** -\r\nFor simplicity, we use the binomial pricing model with three variables (up factor u, down factor d, and interest rate r). At the beginning, we don't have a concrete idea about the value of different variables. First thing to do in the program is to use training data to tune the model and find the best fitting variable value. Only then we can use the variable to produce correct theoretical price. \r\n\r\n**Time/ Speed** -\r\nOne of the goals is to use this program as the pricing engine to a black-box trading system. This goal poses a significant challenge and has a strict time requirement. To catch the mispricing arbitrage opportunities in the market, the system needs to react to a variety of products and provide pricing suggestions almost in real time. We will try our best to speed up the program and see if we can complete calculation in single digit second or even less than a second.\r\n\r\n### Resources\r\n**Computer Platform**:    \r\n\r\nCPU and Nvidia GPU platform (potential benefit from GPU parallel computing)       \r\n\r\n**Coding Language**:      \r\n\r\nC/C++        \r\n\r\n**Textbook Reference**:     \r\n\r\nStochastic Calculus for Finance I: The Binomial Asset Pricing Model by Steven E. Shreve.       \r\n\r\n**Faculty Advisers**:       \r\n\r\nDr. David Handron (CMU-21370)             \r\n\r\nProf. William Hrusa (CMU-21378)         \r\n\r\nProf. Todd C. Mowry (CMU-15418)        \r\n\r\nProf. Brian Railing (CMU-15418)        \r\n\r\n### Authors and Contributors\r\nTeam Members: Qifang “Charlie” Cai (@caiqifang), Xiqiao Shan (@firekarlshanxq)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}